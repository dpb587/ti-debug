/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// Generate js file as follows:
//
// /usr/local/re2c-0.13.5/bin/re2c -Fisc lib/ti-debug/web/inspector/ti-debug/SourcePHPTokenizer.re2js \
// | sed 's|^yy\([^:]*\)*\:|case \1:|' \
// | sed 's|[*]cursor[+][+]|this._charAt(cursor++)|' \
// | sed 's|[[*][+][+]cursor|this._charAt(++cursor)|' \
// | sed 's|[*]cursor|this._charAt(cursor)|' \
// | sed 's|yych = \*\([^;]*\)|yych = this._charAt\1|' \
// | sed 's|goto case \([^;]*\)|{ gotoCase = \1; continue; }|' \
// | sed 's|yych <= \(0x[0-9a-fA-F]*\)|yych <= String.fromCharCode(\1)|' \
// | sed 's|unsigned\ int|var|' \
// | sed 's|var\ yych|case 1: var yych|'

/**
 * @constructor
 * @extends {WebInspector.SourceTokenizer}
 */
WebInspector.SourceJavaScriptTokenizer = function()
{
    WebInspector.SourceTokenizer.call(this);

    this._lexConditions = {
        INITIAL: 0,
        ST_IN_SCRIPTING: 1,
        ST_LOOKING_FOR_PROPERTY: 2,
        ST_BACKQUOTE: 3,
        ST_DOUBLE_QUOTES: 4,
        ST_HEREDOC: 5,
        ST_LOOKING_FOR_VARNAME : 6,
        ST_VAR_OFFSET : 7,
        ST_END_HEREDOC : 8,
        ST_NOWDOC : 9
    };

    this.case_INITIAL = 1000;
    this.case_ST_IN_SCRIPTING = 1001;
    this.case_ST_LOOKING_FOR_PROPERTY = 1002;
    this.case_ST_BACKQUOTE = 1003;
    this.case_ST_DOUBLE_QUOTES = 1004;
    this.case_ST_HEREDOC = 1005;
    this.case_ST_LOOKING_FOR_VARNAME = 1006;
    this.case_ST_VAR_OFFSET = 1007;
    this.case_ST_END_HEREDOC = 1008;
    this.case_ST_NOWDOC = 1009;

    this.condition = this.createInitialCondition();
}

WebInspector.SourceJavaScriptTokenizer.Keywords = [
        "and", "or", "xor", "__FILE__", "exception", "php_user_filter", "__LINE__", "array", "as",
        "break", "case", "cfunction", "class", "const", "continue", "declare", "default", "die",
        "do", "each", "echo", "else", "elseif", "empty", "enddeclare", "endfor", "endforeach",
        "endif", "endswitch", "endwhile", "eval", "exit", "extends", "for", "foreach", "function",
        "global", "if", "isset", "list", "new", "old_function", "print", "return", "static",
        "switch", "unset", "use", "var", "while", "__FUNCTION__", "__CLASS__", "__METHOD__"
    ].keySet();

WebInspector.SourceJavaScriptTokenizer.prototype = {
    createInitialCondition: function()
    {
        return { lexCondition: this._lexConditions.INITIAL };
    },

    nextToken: function(cursor)
    {
        var cursorOnEnter = cursor;
        var gotoCase = 1;
        var YYMARKER;
        while (1) {
            switch (gotoCase)
            // Following comment is replaced with generated state machine.
            /*!re2c
                re2c:define:YYCTYPE  = "var";
                re2c:define:YYCURSOR = cursor;
                re2c:define:YYGETCONDITION = "this.getLexCondition";
                re2c:define:YYSETCONDITION = "this.setLexCondition";
                re2c:condprefix = "case this.case_";
                re2c:condenumprefix = "this._lexConditions.";
                re2c:yyfill:enable = 0;
                re2c:yyfill:check = 0;
                re2c:labelprefix = "case ";
                re2c:indent:top = 2;
                re2c:indent:string = "    ";
                LNUM	[0-9]+
                DNUM	([0-9]*"."[0-9]+)|([0-9]+"."[0-9]*)
                EXPONENT_DNUM	(({LNUM}|{DNUM})[eE][+-]?{LNUM})
                HNUM	"0x"[0-9a-fA-F]+
                BNUM	"0b"[01]+
                LABEL	[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*
                WHITESPACE [ \n\r\t]+
                TABS_AND_SPACES [ \t]*
                TOKENS [;:,.\[\]()|^&+-/*=%!~$<>?@]
                ANY_CHAR [^]
                NEWLINE ("\r"|"\n"|"\r\n")
                
                /* compute yyleng before each rule */
                /*<!*> := yyleng = YYCURSOR - SCNG(yy_text);*/
                
                
                <ST_IN_SCRIPTING>"exit" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"die" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"function" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"const" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"return" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"try" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"catch" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"throw" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"if" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"elseif" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"endif" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"else" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"while" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"endwhile" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"do" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"for" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"endfor" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"foreach" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"endforeach" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"declare" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"enddeclare" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"instanceof" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"as" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"switch" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"endswitch" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"case" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"default" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"break" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"continue" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"goto" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"echo" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"print" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"class" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"interface" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"trait" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"extends" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"implements" { this.tokenType = 'php-keyword'; return cursor; }
                
                <ST_IN_SCRIPTING>"->" {
                    this.setLexCondition(this._lexConditions.ST_LOOKING_FOR_PROPERTY);
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING,ST_LOOKING_FOR_PROPERTY>{WHITESPACE}+ {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_LOOKING_FOR_PROPERTY>"->" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_LOOKING_FOR_PROPERTY>{LABEL} {
                    this.tokenType = 'php-string';
                    return cursor;
                }
                
                <ST_LOOKING_FOR_PROPERTY>{ANY_CHAR} {
                /* @todo
                	yyless(0);
                	yy_pop_state(TSRMLS_C);
                	goto restart;
                */
                }
                
                <ST_IN_SCRIPTING>"::" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"\\" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"new" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"clone" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"var" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"("{TABS_AND_SPACES}("int"|"integer"){TABS_AND_SPACES}")" {
                    this.tokenType = 'php-typecast';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"("{TABS_AND_SPACES}("real"|"double"|"float"){TABS_AND_SPACES}")" {
                    this.tokenType = 'php-typecast';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"("{TABS_AND_SPACES}("string"|"binary"){TABS_AND_SPACES}")" {
                    this.tokenType = 'php-typecast';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"("{TABS_AND_SPACES}"array"{TABS_AND_SPACES}")" {
                    this.tokenType = 'php-typecast';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"("{TABS_AND_SPACES}"object"{TABS_AND_SPACES}")" {
                    this.tokenType = 'php-typecast';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"("{TABS_AND_SPACES}("bool"|"boolean"){TABS_AND_SPACES}")" {
                    this.tokenType = 'php-typecast';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"("{TABS_AND_SPACES}("unset"){TABS_AND_SPACES}")" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"eval" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"include" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"include_once" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"require" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"require_once" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"namespace" {
                    this.tokenType = 'php-namespace';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"use" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"insteadof" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"global" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"isset" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"empty" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"__halt_compiler" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"static" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"abstract" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"final" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"private" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"protected" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"public" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"unset" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"=>" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"list" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"array" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"callable" {
                    this.tokenType = 'php-keyword';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"++" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"--" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"===" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"!==" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"==" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"!="|"<>" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"<=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>">=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"+=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"-=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"*=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"/=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>".=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"%=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"<<=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>">>=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"&=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"|=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"^=" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"||" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"&&" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"OR" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"AND" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"XOR" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"<<" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>">>" {
                    this.tokenType = null;
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>{TOKENS} {
                	return yytext[0];
                }
                
                
                <ST_IN_SCRIPTING>"{" {
                    this.setLexCondition(this._lexConditions.ST_IN_SCRIPTING);
                    this.tokenType = null;
                    return cursor;
                }
                
                
                <ST_DOUBLE_QUOTES,ST_BACKQUOTE,ST_HEREDOC>"${" {
                    this.setLexCondition(this._lexConditions.ST_LOOKING_FOR_VARNAME);
                    this.tokenType = null;
                    return cursor;
                }
                
                
                <ST_IN_SCRIPTING>"}" {
                	/*@todo RESET_DOC_COMMENT();*/
                	this.tokenType = null;
                	return cursor;
                }
                
                
                <ST_LOOKING_FOR_VARNAME>{LABEL}[[}] {
                    this.setLexCondition(this._lexConditions.ST_IN_SCRIPTING);
                    this.tokenType = 'php-ident';
                    return cursor;
                }
                
                
                <ST_LOOKING_FOR_VARNAME>{ANY_CHAR} {
                    this.setLexCondition(this._lexConditions.ST_IN_SCRIPTING);
                    this.tokenType = 'php-ident';
                    return cursor;
                    /*@todo                	goto restart; */
                }
                
                <ST_IN_SCRIPTING>{BNUM} {
                    this.tokenType = 'php-number';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>{LNUM} {
                    this.tokenType = 'php-number';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>{HNUM} {
                    this.tokenType = 'php-number';
                    return cursor;
                }
                
                <ST_VAR_OFFSET>[0]|([1-9][0-9]*) {
                    this.tokenType = 'php-string';
                    return cursor;
                }
                
                <ST_VAR_OFFSET>{LNUM}|{HNUM}|{BNUM} {
                    this.tokenType = 'php-string';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>{DNUM}|{EXPONENT_DNUM} {
                    this.tokenType = 'php-number';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"__CLASS__" {
                    this.tokenType = 'php-ident';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"__TRAIT__" {
                    this.tokenType = 'php-ident';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"__FUNCTION__" {
                    this.tokenType = 'php-ident';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"__METHOD__" {
                    this.tokenType = 'php-ident';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"__LINE__" {
                    this.tokenType = 'php-ident';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"__FILE__" {
                    this.tokenType = 'php-ident';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"__DIR__" {
                    this.tokenType = 'php-ident';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING>"__NAMESPACE__" {
                    this.tokenType = 'php-ident';
                    return cursor;
                }
                
                <INITIAL>"<script"{WHITESPACE}+"language"{WHITESPACE}*"="{WHITESPACE}*("php"|"\"php\""|"'php'"){WHITESPACE}*">" {
                    this.setLexCondition(this._lexConditions.ST_IN_SCRIPTING);
                    // @todo
                    return cursor;
                }
                
                
                <INITIAL>"<%=" {
                    /* always assuming enabled */
                    this.setLexCondition(this._lexConditions.ST_IN_SCRIPTING);
                    return cursor;
                }
                
                
                <INITIAL>"<?=" {
                    this.setLexCondition(this._lexConditions.ST_IN_SCRIPTING);
                    return cursor;
                }
                
                
                <INITIAL>"<%" {
                    /* always assuming enabled */
                    this.setLexCondition(this._lexConditions.ST_IN_SCRIPTING);
                    return cursor;
                }
                
                
                <INITIAL>"<?php"([ \t]|{NEWLINE}) {
                    /* always assuming enabled */
                    this.setLexCondition(this._lexConditions.ST_IN_SCRIPTING);
                    return cursor;
                }
                
                
                <INITIAL>"<?" {
                    /* always assuming enabled */
                    this.setLexCondition(this._lexConditions.ST_IN_SCRIPTING);
                    return cursor;
                }
                
                <INITIAL>{ANY_CHAR} {
                	/* @todo */
                }
                
                /* Make sure a label character follows "->", otherwise there is no property
                 * and "->" will be taken literally
                 */
                <ST_DOUBLE_QUOTES,ST_HEREDOC,ST_BACKQUOTE>"$"{LABEL}"->"[a-zA-Z_\x7f-\xff] {
                	yyless(yyleng - 3);
                	yy_push_state(ST_LOOKING_FOR_PROPERTY TSRMLS_CC);
                	zend_copy_value(zendlval, (yytext+1), (yyleng-1));
                	zendlval->type = IS_STRING;
                	return T_VARIABLE;
                }
                
                /* A [ always designates a variable offset, regardless of what follows
                 */
                <ST_DOUBLE_QUOTES,ST_HEREDOC,ST_BACKQUOTE>"$"{LABEL}"[" {
                    this.tokenType = 'php-ident';
                    return cursor;
                }
                
                <ST_IN_SCRIPTING,ST_DOUBLE_QUOTES,ST_HEREDOC,ST_BACKQUOTE,ST_VAR_OFFSET>"$"{LABEL} {
                    this.tokenType = 'php-ident';
                    return cursor;
                }
                
                <ST_VAR_OFFSET>"]" {
                    return cursor;
                }
                
                <ST_VAR_OFFSET>{TOKENS}|[{}"`] {
                    // @todo?
                    return cursor;
                }
                
                <ST_VAR_OFFSET>[ \n\r\t\\'#] {
                    // @todo
                    return cursor;
                }
                
                <ST_IN_SCRIPTING,ST_VAR_OFFSET>{LABEL} {
                    this.tokenType = 'php-string';
                    return cursor;
                }
                
                
                <ST_IN_SCRIPTING>"#"|"//" {
                    
                	while (YYCURSOR < YYLIMIT) {
                		switch (*YYCURSOR++) {
                			case '\r':
                				if (*YYCURSOR == '\n') {
                					YYCURSOR++;
                				}
                				/* fall through */
                			case '\n':
                				CG(zend_lineno)++;
                				break;
                			case '%':
                				if (!CG(asp_tags)) {
                					continue;
                				}
                				/* fall through */
                			case '?':
                				if (*YYCURSOR == '>') {
                					YYCURSOR--;
                					break;
                				}
                				/* fall through */
                			default:
                				continue;
                		}
                
                		break;
                	}
                
                	yyleng = YYCURSOR - SCNG(yy_text);
                
                	return T_COMMENT;
                }
                
                <ST_IN_SCRIPTING>"/*"|"/**"{WHITESPACE} {
                	int doc_com;
                
                	if (yyleng > 2) {
                		doc_com = 1;
                		RESET_DOC_COMMENT();
                	} else {
                		doc_com = 0;
                	}
                
                	while (YYCURSOR < YYLIMIT) {
                		if (*YYCURSOR++ == '*' && *YYCURSOR == '/') {
                			break;
                		}
                	}
                
                	if (YYCURSOR < YYLIMIT) {
                		YYCURSOR++;
                	} else {
                		zend_error(E_COMPILE_WARNING, "Unterminated comment starting line %d", CG(zend_lineno));
                	}
                
                	yyleng = YYCURSOR - SCNG(yy_text);
                	HANDLE_NEWLINES(yytext, yyleng);
                
                	if (doc_com) {
                		CG(doc_comment) = estrndup(yytext, yyleng);
                		CG(doc_comment_len) = yyleng;
                		return T_DOC_COMMENT;
                	}
                
                	return T_COMMENT;
                }
                
                <ST_IN_SCRIPTING>("?>"|"</script"{WHITESPACE}*">"){NEWLINE}? {
                	zendlval->value.str.val = yytext; /* no copying - intentional */
                	zendlval->value.str.len = yyleng;
                	zendlval->type = IS_STRING;
                	BEGIN(INITIAL);
                	return T_CLOSE_TAG;  /* implicit ';' at php-end tag */
                }
                
                
                <ST_IN_SCRIPTING>"%>"{NEWLINE}? {
                	if (CG(asp_tags)) {
                		BEGIN(INITIAL);
                		zendlval->value.str.len = yyleng;
                		zendlval->type = IS_STRING;
                		zendlval->value.str.val = yytext; /* no copying - intentional */
                		return T_CLOSE_TAG;  /* implicit ';' at php-end tag */
                	} else {
                		yyless(1);
                		return yytext[0];
                	}
                }
                
                
                <ST_IN_SCRIPTING>b?['] {
                	register char *s, *t;
                	char *end;
                	int bprefix = (yytext[0] != '\'') ? 1 : 0;
                
                	while (1) {
                		if (YYCURSOR < YYLIMIT) {
                			if (*YYCURSOR == '\'') {
                				YYCURSOR++;
                				yyleng = YYCURSOR - SCNG(yy_text);
                
                				break;
                			} else if (*YYCURSOR++ == '\\' && YYCURSOR < YYLIMIT) {
                				YYCURSOR++;
                			}
                		} else {
                			yyleng = YYLIMIT - SCNG(yy_text);
                
                			/* Unclosed single quotes; treat similar to double quotes, but without a separate token
                			 * for ' (unrecognized by parser), instead of old flex fallback to "Unexpected character..."
                			 * rule, which continued in ST_IN_SCRIPTING state after the quote */
                			return T_ENCAPSED_AND_WHITESPACE;
                		}
                	}
                
                	zendlval->value.str.val = estrndup(yytext+bprefix+1, yyleng-bprefix-2);
                	zendlval->value.str.len = yyleng-bprefix-2;
                	zendlval->type = IS_STRING;
                
                	/* convert escape sequences */
                	s = t = zendlval->value.str.val;
                	end = s+zendlval->value.str.len;
                	while (s<end) {
                		if (*s=='\\') {
                			s++;
                
                			switch(*s) {
                				case '\\':
                				case '\'':
                					*t++ = *s;
                					zendlval->value.str.len--;
                					break;
                				default:
                					*t++ = '\\';
                					*t++ = *s;
                					break;
                			}
                		} else {
                			*t++ = *s;
                		}
                
                		if (*s == '\n' || (*s == '\r' && (*(s+1) != '\n'))) {
                			CG(zend_lineno)++;
                		}
                		s++;
                	}
                	*t = 0;
                
                	if (SCNG(output_filter)) {
                		size_t sz = 0;
                		s = zendlval->value.str.val;
                		SCNG(output_filter)((unsigned char **)&(zendlval->value.str.val), &sz, (unsigned char *)s, (size_t)zendlval->value.str.len TSRMLS_CC);
                		zendlval->value.str.len = sz;
                		efree(s);
                	}
                	return T_CONSTANT_ENCAPSED_STRING;
                }
                
                
                <ST_IN_SCRIPTING>b?["] {
                	int bprefix = (yytext[0] != '"') ? 1 : 0;
                
                	while (YYCURSOR < YYLIMIT) {
                		switch (*YYCURSOR++) {
                			case '"':
                				yyleng = YYCURSOR - SCNG(yy_text);
                				zend_scan_escape_string(zendlval, yytext+bprefix+1, yyleng-bprefix-2, '"' TSRMLS_CC);
                				return T_CONSTANT_ENCAPSED_STRING;
                			case '$':
                				if (IS_LABEL_START(*YYCURSOR) || *YYCURSOR == '{') {
                					break;
                				}
                				continue;
                			case '{':
                				if (*YYCURSOR == '$') {
                					break;
                				}
                				continue;
                			case '\\':
                				if (YYCURSOR < YYLIMIT) {
                					YYCURSOR++;
                				}
                				/* fall through */
                			default:
                				continue;
                		}
                
                		YYCURSOR--;
                		break;
                	}
                
                	/* Remember how much was scanned to save rescanning */
                	SET_DOUBLE_QUOTES_SCANNED_LENGTH(YYCURSOR - SCNG(yy_text) - yyleng);
                
                	YYCURSOR = SCNG(yy_text) + yyleng;
                
                	BEGIN(ST_DOUBLE_QUOTES);
                	return '"';
                }
                
                
                <ST_IN_SCRIPTING>b?"<<<"{TABS_AND_SPACES}({LABEL}|([']{LABEL}['])|(["]{LABEL}["])){NEWLINE} {
                	char *s;
                	int bprefix = (yytext[0] != '<') ? 1 : 0;
                
                	/* save old heredoc label */
                	Z_STRVAL_P(zendlval) = CG(heredoc);
                	Z_STRLEN_P(zendlval) = CG(heredoc_len);
                
                	CG(zend_lineno)++;
                	CG(heredoc_len) = yyleng-bprefix-3-1-(yytext[yyleng-2]=='\r'?1:0);
                	s = yytext+bprefix+3;
                	while ((*s == ' ') || (*s == '\t')) {
                		s++;
                		CG(heredoc_len)--;
                	}
                
                	if (*s == '\'') {
                		s++;
                		CG(heredoc_len) -= 2;
                
                		BEGIN(ST_NOWDOC);
                	} else {
                		if (*s == '"') {
                			s++;
                			CG(heredoc_len) -= 2;
                		}
                
                		BEGIN(ST_HEREDOC);
                	}
                
                	CG(heredoc) = estrndup(s, CG(heredoc_len));
                
                	/* Check for ending label on the next line */
                	if (CG(heredoc_len) < YYLIMIT - YYCURSOR && !memcmp(YYCURSOR, s, CG(heredoc_len))) {
                		YYCTYPE *end = YYCURSOR + CG(heredoc_len);
                
                		if (*end == ';') {
                			end++;
                		}
                
                		if (*end == '\n' || *end == '\r') {
                			BEGIN(ST_END_HEREDOC);
                		}
                	}
                
                	return T_START_HEREDOC;
                }
                
                
                <ST_IN_SCRIPTING>[`] {
                	BEGIN(ST_BACKQUOTE);
                	return '`';
                }
                
                
                <ST_END_HEREDOC>{ANY_CHAR} {
                	YYCURSOR += CG(heredoc_len) - 1;
                	yyleng = CG(heredoc_len);
                
                	Z_STRVAL_P(zendlval) = CG(heredoc);
                	Z_STRLEN_P(zendlval) = CG(heredoc_len);
                	CG(heredoc) = NULL;
                	CG(heredoc_len) = 0;
                	BEGIN(ST_IN_SCRIPTING);
                	return T_END_HEREDOC;
                }
                
                
                <ST_DOUBLE_QUOTES,ST_BACKQUOTE,ST_HEREDOC>"{$" {
                	zendlval->value.lval = (long) '{';
                	yy_push_state(ST_IN_SCRIPTING TSRMLS_CC);
                	yyless(1);
                	return T_CURLY_OPEN;
                }
                
                
                <ST_DOUBLE_QUOTES>["] {
                	BEGIN(ST_IN_SCRIPTING);
                	return '"';
                }
                
                <ST_BACKQUOTE>[`] {
                	BEGIN(ST_IN_SCRIPTING);
                	return '`';
                }
                
                
                <ST_DOUBLE_QUOTES>{ANY_CHAR} {
                	if (GET_DOUBLE_QUOTES_SCANNED_LENGTH()) {
                		YYCURSOR += GET_DOUBLE_QUOTES_SCANNED_LENGTH() - 1;
                		SET_DOUBLE_QUOTES_SCANNED_LENGTH(0);
                
                		goto double_quotes_scan_done;
                	}
                
                	if (YYCURSOR > YYLIMIT) {
                		return 0;
                	}
                	if (yytext[0] == '\\' && YYCURSOR < YYLIMIT) {
                		YYCURSOR++;
                	}
                
                	while (YYCURSOR < YYLIMIT) {
                		switch (*YYCURSOR++) {
                			case '"':
                				break;
                			case '$':
                				if (IS_LABEL_START(*YYCURSOR) || *YYCURSOR == '{') {
                					break;
                				}
                				continue;
                			case '{':
                				if (*YYCURSOR == '$') {
                					break;
                				}
                				continue;
                			case '\\':
                				if (YYCURSOR < YYLIMIT) {
                					YYCURSOR++;
                				}
                				/* fall through */
                			default:
                				continue;
                		}
                
                		YYCURSOR--;
                		break;
                	}
                
                double_quotes_scan_done:
                	yyleng = YYCURSOR - SCNG(yy_text);
                
                	zend_scan_escape_string(zendlval, yytext, yyleng, '"' TSRMLS_CC);
                	return T_ENCAPSED_AND_WHITESPACE;
                }
                
                
                <ST_BACKQUOTE>{ANY_CHAR} {
                	if (YYCURSOR > YYLIMIT) {
                		return 0;
                	}
                	if (yytext[0] == '\\' && YYCURSOR < YYLIMIT) {
                		YYCURSOR++;
                	}
                
                	while (YYCURSOR < YYLIMIT) {
                		switch (*YYCURSOR++) {
                			case '`':
                				break;
                			case '$':
                				if (IS_LABEL_START(*YYCURSOR) || *YYCURSOR == '{') {
                					break;
                				}
                				continue;
                			case '{':
                				if (*YYCURSOR == '$') {
                					break;
                				}
                				continue;
                			case '\\':
                				if (YYCURSOR < YYLIMIT) {
                					YYCURSOR++;
                				}
                				/* fall through */
                			default:
                				continue;
                		}
                
                		YYCURSOR--;
                		break;
                	}
                
                	yyleng = YYCURSOR - SCNG(yy_text);
                
                	zend_scan_escape_string(zendlval, yytext, yyleng, '`' TSRMLS_CC);
                	return T_ENCAPSED_AND_WHITESPACE;
                }
                
                
                <ST_HEREDOC>{ANY_CHAR} {
                	int newline = 0;
                
                	if (YYCURSOR > YYLIMIT) {
                		return 0;
                	}
                
                	YYCURSOR--;
                
                	while (YYCURSOR < YYLIMIT) {
                		switch (*YYCURSOR++) {
                			case '\r':
                				if (*YYCURSOR == '\n') {
                					YYCURSOR++;
                				}
                				/* fall through */
                			case '\n':
                				/* Check for ending label on the next line */
                				if (IS_LABEL_START(*YYCURSOR) && CG(heredoc_len) < YYLIMIT - YYCURSOR && !memcmp(YYCURSOR, CG(heredoc), CG(heredoc_len))) {
                					YYCTYPE *end = YYCURSOR + CG(heredoc_len);
                
                					if (*end == ';') {
                						end++;
                					}
                
                					if (*end == '\n' || *end == '\r') {
                						/* newline before label will be subtracted from returned text, but
                						 * yyleng/yytext will include it, for zend_highlight/strip, tokenizer, etc. */
                						if (YYCURSOR[-2] == '\r' && YYCURSOR[-1] == '\n') {
                							newline = 2; /* Windows newline */
                						} else {
                							newline = 1;
                						}
                
                						CG(increment_lineno) = 1; /* For newline before label */
                						BEGIN(ST_END_HEREDOC);
                
                						goto heredoc_scan_done;
                					}
                				}
                				continue;
                			case '$':
                				if (IS_LABEL_START(*YYCURSOR) || *YYCURSOR == '{') {
                					break;
                				}
                				continue;
                			case '{':
                				if (*YYCURSOR == '$') {
                					break;
                				}
                				continue;
                			case '\\':
                				if (YYCURSOR < YYLIMIT && *YYCURSOR != '\n' && *YYCURSOR != '\r') {
                					YYCURSOR++;
                				}
                				/* fall through */
                			default:
                				continue;
                		}
                
                		YYCURSOR--;
                		break;
                	}
                
                heredoc_scan_done:
                	yyleng = YYCURSOR - SCNG(yy_text);
                
                	zend_scan_escape_string(zendlval, yytext, yyleng - newline, 0 TSRMLS_CC);
                	return T_ENCAPSED_AND_WHITESPACE;
                }
                
                
                <ST_NOWDOC>{ANY_CHAR} {
                	int newline = 0;
                
                	if (YYCURSOR > YYLIMIT) {
                		return 0;
                	}
                
                	YYCURSOR--;
                
                	while (YYCURSOR < YYLIMIT) {
                		switch (*YYCURSOR++) {
                			case '\r':
                				if (*YYCURSOR == '\n') {
                					YYCURSOR++;
                				}
                				/* fall through */
                			case '\n':
                				/* Check for ending label on the next line */
                				if (IS_LABEL_START(*YYCURSOR) && CG(heredoc_len) < YYLIMIT - YYCURSOR && !memcmp(YYCURSOR, CG(heredoc), CG(heredoc_len))) {
                					YYCTYPE *end = YYCURSOR + CG(heredoc_len);
                
                					if (*end == ';') {
                						end++;
                					}
                
                					if (*end == '\n' || *end == '\r') {
                						/* newline before label will be subtracted from returned text, but
                						 * yyleng/yytext will include it, for zend_highlight/strip, tokenizer, etc. */
                						if (YYCURSOR[-2] == '\r' && YYCURSOR[-1] == '\n') {
                							newline = 2; /* Windows newline */
                						} else {
                							newline = 1;
                						}
                
                						CG(increment_lineno) = 1; /* For newline before label */
                						BEGIN(ST_END_HEREDOC);
                
                						goto nowdoc_scan_done;
                					}
                				}
                				/* fall through */
                			default:
                				continue;
                		}
                	}
                
                nowdoc_scan_done:
                	yyleng = YYCURSOR - SCNG(yy_text);
                
                	zend_copy_value(zendlval, yytext, yyleng - newline);
                	zendlval->type = IS_STRING;
                	HANDLE_NEWLINES(yytext, yyleng - newline);
                	return T_ENCAPSED_AND_WHITESPACE;
                }
                
                
                <ST_IN_SCRIPTING,ST_VAR_OFFSET>{ANY_CHAR} {
                	if (YYCURSOR > YYLIMIT) {
                		return 0;
                	}
                
                	zend_error(E_COMPILE_WARNING,"Unexpected character in input:  '%c' (ASCII=%d) state=%d", yytext[0], yytext[0], YYSTATE);
                	goto restart;
                }
            */
        }
    }
}

WebInspector.SourceJavaScriptTokenizer.prototype.__proto__ = WebInspector.SourceTokenizer.prototype;
